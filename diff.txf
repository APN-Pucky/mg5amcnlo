=== modified file '.pydevproject'
--- .pydevproject	2010-05-07 15:31:59 +0000
+++ .pydevproject	2010-05-21 14:29:13 +0000
@@ -5,6 +5,6 @@
 <pydev_property name="org.python.pydev.PYTHON_PROJECT_VERSION">python 2.6</pydev_property>
 <pydev_property name="org.python.pydev.PYTHON_PROJECT_INTERPRETER">Default</pydev_property>
 <pydev_pathproperty name="org.python.pydev.PROJECT_SOURCE_PATH">
-<path>/MG5_on_web</path>
+<path>/export_model</path>
 </pydev_pathproperty>
 </pydev_project>

=== modified file 'madgraph/core/base_objects.py'
--- madgraph/core/base_objects.py	2010-05-06 03:10:37 +0000
+++ madgraph/core/base_objects.py	2010-05-25 19:14:14 +0000
@@ -19,6 +19,7 @@
 import copy
 import itertools
 import logging
+import numbers
 import re
 
 import madgraph.core.color_algebra as color
@@ -210,6 +211,11 @@
     particle object is a particle or an antiparticle. The self_antipart flag
     tells if the particle is its own antiparticle."""
 
+    sorted_keys = ['name', 'antiname', 'spin', 'color',
+                   'charge', 'mass', 'width', 'pdg_code',
+                   'texname', 'antitexname', 'line', 'propagating',
+                   'is_part', 'self_antipart']
+
     def default_setup(self):
         """Default values for all properties"""
 
@@ -277,7 +283,7 @@
                    "Line type %s is unknown" % value
 
         if name is 'charge':
-            if not isinstance(value, float):
+            if not isinstance(value, numbers.Number):
                 raise self.PhysicsObjectError, \
                     "Charge %s is not a float" % repr(value)
 
@@ -296,10 +302,7 @@
     def get_sorted_keys(self):
         """Return particle property names as a nicely sorted list."""
 
-        return ['name', 'antiname', 'spin', 'color',
-                'charge', 'mass', 'width', 'pdg_code',
-                'texname', 'antitexname', 'line', 'propagating',
-                'is_part', 'self_antipart']
+        return self.sorted_keys
 
     # Helper functions
 
@@ -385,6 +388,7 @@
     def is_valid_element(self, obj):
         """Test if object obj is a valid Particle for the list."""
         return isinstance(obj, Particle)
+                    
 
     def find_name(self, name):
         """Try to find a particle with the given name. Check both name
@@ -452,6 +456,8 @@
     orders: dictionary listing order names (as keys) with their value
     """
 
+    sorted_keys = ['id', 'particles', 'color', 'lorentz', 'couplings', 'orders']
+
     def default_setup(self):
         """Default values for all properties"""
 
@@ -537,15 +543,15 @@
                         "%s is not a valid tuple of integer" % str(key)
                 if not isinstance(value[key], str):
                     raise self.PhysicsObjectError, \
-                        "%s is not a valid string" % str(mystr)
+                        "%s is not a valid string" % value[key]
 
         return True
 
     def get_sorted_keys(self):
         """Return particle property names as a nicely sorted list."""
 
-        return ['id', 'particles', 'color', 'lorentz',
-                'couplings', 'orders']
+        return self.sorted_keys 
+                
 
     def generate_dict_entries(self, ref_dict_to0, ref_dict_to1):
         """Add entries corresponding to the current interactions to 
@@ -1007,7 +1013,9 @@
 class Vertex(PhysicsObject):
     """Vertex: list of legs (ordered), id (Interaction)
     """
-
+    
+    sorted_keys = ['id', 'legs']
+    
     def default_setup(self):
         """Default values for all properties"""
 
@@ -1032,7 +1040,7 @@
     def get_sorted_keys(self):
         """Return particle property names as a nicely sorted list."""
 
-        return ['id', 'legs']
+        return self.sorted_keys  #['id', 'legs']
 
     def get_s_channel_id(self, model, ninitial):
         """Returns the id for the last leg as an outgoing

=== modified file 'madgraph/core/helas_objects.py'
--- madgraph/core/helas_objects.py	2010-04-30 07:00:56 +0000
+++ madgraph/core/helas_objects.py	2010-05-25 23:31:20 +0000
@@ -13,11 +13,10 @@
 #
 ################################################################################
 
+
 import array
 import copy
-import gc
 import logging
-import re
 import itertools
 import math
 
@@ -3233,7 +3232,7 @@
         decay processes (separately)"""
 
         if not isinstance(dc_amplitude, diagram_generation.DecayChainAmplitude):
-            raise base_objects.PhysicsObjectError, \
+            raise self.PhysicsObjectError, \
                   "%s is not a valid DecayChainAmplitude" % dc_amplitude
 
         matrix_elements = self['core_processes']

=== modified file 'madgraph/interface/cmd_interface.py'
--- madgraph/interface/cmd_interface.py	2010-05-18 22:05:04 +0000
+++ madgraph/interface/cmd_interface.py	2010-05-27 08:27:59 +0000
@@ -42,6 +42,8 @@
 import madgraph.iolibs.drawing as draw_lib
 import madgraph.iolibs.drawing_eps as draw
 
+import models as ufomodels
+
 #position of MG5
 root_path = os.path.split(os.path.dirname(os.path.realpath(__file__)))[0]
 root_path = os.path.split(root_path)[0]
@@ -366,7 +368,7 @@
             return False
         
         if args[0] == 'madevent_v4' and  not os.path.isdir(
-                                        os.path.join(path,'..','SubProcesses')):
+                                        os.path.join(path, '..', 'SubProcesses')):
             print "%s is not a valid directory for export file" % path
             print "to create a valid output directory you can use the command"
             print "$> setup madevent_v4 auto" 
@@ -423,7 +425,7 @@
             self.help_import()
             return False
         
-        if args[0] == 'proc_v4' and len(args)!=2 and not self._export_dir:
+        if args[0] == 'proc_v4' and len(args) != 2 and not self._export_dir:
             self.help_import()
             return False            
         
@@ -502,7 +504,7 @@
         """check the validity of line
         No Path authorize for the Web"""
         
-        if len(args) == 2 and args[1] not in ['.','clean']:
+        if len(args) == 2 and args[1] not in ['.', 'clean']:
             return False
         
         return CheckValidForCmd.check_history(self, args)
@@ -537,7 +539,7 @@
         """ check the validity of the line
         No Path authorize for the Web"""
         
-        if len(args)==2:
+        if len(args) == 2:
             if args[0] != 'model':
                 print 'only model can be load online'
                 return False
@@ -673,7 +675,7 @@
         #option
         if len(split_arg(line[0:begidx])) >= 2:
             opt = ['horizontal', 'external=', 'max_size=', 'add_gap=',
-                                'non_propagating','--']
+                                'non_propagating', '--']
             return self.list_completion(text, opt)
 
     def complete_load(self, text, line, begidx, endidx):
@@ -718,8 +720,8 @@
         possible_format = ['madevent_v4']
         #don't propose directory use by MG_ME
         forbidden_name = ['MadGraphII', 'Template', 'pythia-pgs', 'CVS',
-                            'Calculators', 'MadAnalysis', 'SimpleAnalysis', 
-                            'mg5', 'DECAY', 'EventConverter', 'Models', 
+                            'Calculators', 'MadAnalysis', 'SimpleAnalysis',
+                            'mg5', 'DECAY', 'EventConverter', 'Models',
                             'ExRootAnalysis', 'HELAS', 'Transfer_Fct']
         # Format
         if len(split_arg(line[0:begidx])) == 1:
@@ -750,7 +752,7 @@
 
         # Filename if directory is given
         #
-        if len(split_arg(line[0:begidx])) > 1 and line[begidx-1] == os.path.sep:
+        if len(split_arg(line[0:begidx])) > 1 and line[begidx - 1] == os.path.sep:
             if not text:
                 text = ''
             output = self.path_completion(text,
@@ -797,7 +799,7 @@
     _display_opts = ['particles', 'interactions', 'processes', 'multiparticles']
     _add_opts = ['process']
     _save_opts = ['model', 'processes']
-    _import_formats = ['model_v4', 'proc_v4', 'command']
+    _import_formats = ['model_v4', 'model_v5', 'proc_v4', 'command']
     _export_formats = ['standalone_v4', 'sa_dirs_v4', 'madevent_v4']
         
     def __init__(self, *arg, **opt):
@@ -928,9 +930,13 @@
                              if part['self_antipart']]
             for part in part_antipart:
                 print part['name'] + '/' + part['antiname'],
+                print
+                print part
             print ''
             for part in part_self:
                 print part['name'],
+                print
+                print part
             print ''
 
         if args[0] == 'interactions':
@@ -944,6 +950,7 @@
                     else:
                         print part['antiname'],
                 print
+                print inter
 
         if args[0] == 'processes':
             for amp in self._curr_amps:
@@ -1105,17 +1112,17 @@
             print "Empty or wrong format process, please try again."    
     
     
-    def extract_process(self, line, proc_number = 0):
+    def extract_process(self, line, proc_number=0):
         """Extract a process definition from a string. Returns
         a ProcessDefinition."""
 
         # Perform sanity modifications on the lines:
         # Add a space before any > , $ /
-        space_before=re.compile(r"(?P<carac>\S)(?P<tag>[/\,\\$\\>])")
-        line = space_before.sub(r'\g<carac> \g<tag>',line)       
+        space_before = re.compile(r"(?P<carac>\S)(?P<tag>[/\,\\$\\>])")
+        line = space_before.sub(r'\g<carac> \g<tag>', line)       
         # Add a space after any + - ~ > , $ / 
-        space_after=re.compile(r"(?P<tag>[+-/\,\\$\\>~])(?P<carac>[^\s+-])")
-        line = space_after.sub(r'\g<tag> \g<carac>',line)
+        space_after = re.compile(r"(?P<tag>[+-/\,\\$\\>~])(?P<carac>[^\s+-])")
+        line = space_after.sub(r'\g<tag> \g<carac>', line)
         
         
         # Use regular expressions to extract s-channel propagators,
@@ -1218,10 +1225,10 @@
                 args = split_arg(forbidden_particles)
                 for part_name in args:
                     if part_name in self._multiparticles:
-                        forbidden_particle_ids.extend( \
+                        forbidden_particle_ids.extend(\
                                                self._multiparticles[part_name])
                     else:
-                        mypart = self._curr_model['particles'].find_name( \
+                        mypart = self._curr_model['particles'].find_name(\
                                                                       part_name)
                         if mypart:
                             forbidden_particle_ids.append(mypart.get_pdg_code())
@@ -1389,8 +1396,8 @@
         '#***********************************************************\n'
         
         #Avoid repetition of header
-        if self.history[0] == '#'+'*' * 59:
-            text=''
+        if self.history[0] == '#' + '*' * 59:
+            text = ''
         # Add the comand used 
         text += '\n'.join(self.history) + '\n' 
         
@@ -1434,7 +1441,15 @@
         if not self.check_import(args):
             return
         
-        if args[0] == 'model_v4':
+        if args[0] == 'model_v5':
+            self._curr_model = ufomodels.import_model(args[1])
+            try:
+                self._model_dir = os.path.join(MGME_dir, 'Models', args[1])
+            except:
+                pass
+            self._curr_fortran_model = export_v4.UFOHelasFortranModel()
+                    
+        elif args[0] == 'model_v4':
             # Check for a file
             if os.path.isfile(args[1]):
                 suceed = import_v4file(self, args[1])
@@ -1563,7 +1578,7 @@
             return
         
         path_split = filepath.split(os.path.sep)
-        if len(path_split)>2 and path_split[-2] == 'Cards':
+        if len(path_split) > 2 and path_split[-2] == 'Cards':
             self._export_dir = os.path.sep.join(path_split[:-2])
                 
     
@@ -1645,7 +1660,7 @@
         else:
             makejpg = True
             
-        os.system('touch %s/done' % os.path.join(dir_path,'SubProcesses'))        
+        os.system('touch %s/done' % os.path.join(dir_path, 'SubProcesses'))        
         export_v4.create_v4_webpage(dir_path, makejpg)
 
 
@@ -1826,12 +1841,12 @@
 #===============================================================================
 # Draw Command Parser
 #=============================================================================== 
-_usage =  "draw FILEPATH [options]\n" + \
+_usage = "draw FILEPATH [options]\n" + \
          "-- draw the diagrams in eps format\n" + \
          "   Files will be FILEPATH/diagrams_\"process_string\".eps \n" + \
          "   Example: draw plot_dir . \n"
 _draw_parser = optparse.OptionParser(usage=_usage)
-_draw_parser.add_option("", "--horizontal", default=False, 
+_draw_parser.add_option("", "--horizontal", default=False,
                    action='store_true', help="force S-channel to be horizontal")
 _draw_parser.add_option("", "--external", default=0, type='float',
                     help="authorizes external particles to end at top or " + \
@@ -1840,10 +1855,10 @@
 _draw_parser.add_option("", "--max_size", default=1.5, type='float',
                          help="this forbids external line bigger than max_size")
 _draw_parser.add_option("", "--non_propagating", default=True, \
-                          dest="contract_non_propagating", action='store_false', 
-                          help= "avoid contractions of non propagating lines") 
+                          dest="contract_non_propagating", action='store_false',
+                          help="avoid contractions of non propagating lines") 
 _draw_parser.add_option("", "--add_gap", default=0, type='float', \
-                          help= "set the x-distance between external particles")  
+                          help="set the x-distance between external particles")  
   
     
     

=== modified file 'madgraph/iolibs/export_v4.py'
--- madgraph/iolibs/export_v4.py	2010-05-18 08:48:52 +0000
+++ madgraph/iolibs/export_v4.py	2010-05-28 14:46:04 +0000
@@ -1810,6 +1810,206 @@
                           HelasFortranModel.sort_amp[l1]))
 
 #===============================================================================
+# UFOHelasFortranModel
+#===============================================================================
+class UFOHelasFortranModel(helas_objects.HelasModel):
+    """The class for writing Helas calls in Fortran, starting from
+    HelasWavefunctions and HelasAmplitudes.
+
+    Includes the function generate_helas_call, which automatically
+    generates the Fortran Helas call based on the Lorentz structure of
+    the interaction."""
+
+    def get_wavefunction_call(self, wavefunction):
+        """Return the function for writing the wavefunction
+        corresponding to the key. If the function doesn't exist,
+        generate_helas_call is called to automatically create the
+        function."""
+
+        val = super(UFOHelasFortranModel, self).get_wavefunction_call(wavefunction)
+        if val:
+            return val
+
+        # If function not already existing, try to generate it.
+        self.generate_helas_call(wavefunction)
+        return super(UFOHelasFortranModel, self).get_wavefunction_call(\
+            wavefunction)
+
+    def get_amplitude_call(self, amplitude):
+        """Return the function for writing the amplitude corresponding
+        to the key. If the function doesn't exist, generate_helas_call
+        is called to automatically create the function."""
+
+        val = super(UFOHelasFortranModel, self).get_amplitude_call(amplitude)
+        if val:
+            return val
+        
+        # If function not already existing, try to generate it.
+        self.generate_helas_call(amplitude)
+        return super(HelasFortranModel, self).get_amplitude_call(amplitude)
+
+    def generate_helas_call(self, argument):
+        """Routine for automatic generation of Fortran Helas calls
+        according to just the spin structure of the interaction.
+
+        First the call string is generated, using a dictionary to go
+        from the spin state of the calling wavefunction and its
+        mothers, or the mothers of the amplitude, to letters.
+        -> need update?
+
+        Then the call function is generated, as a lambda which fills
+        the call string with the information of the calling
+        wavefunction or amplitude. The call has different structure,
+        depending on the spin of the wavefunction and the number of
+        mothers (multiplicity of the vertex). The mother
+        wavefunctions, when entering the call, must be sorted in the
+        correct way - this is done by the sorted_mothers routine.
+
+        Finally the call function is stored in the relevant
+        dictionary, in order to be able to reuse the function the next
+        time a wavefunction with the same Lorentz structure is needed.
+        """
+
+        if not isinstance(argument, helas_objects.HelasWavefunction) and \
+           not isinstance(argument, helas_objects.HelasAmplitude):
+            raise self.PhysicsObjectError, \
+                  "get_helas_call must be called with wavefunction or amplitude"
+        
+        call = "CALL "
+
+        call_function = None
+
+        if isinstance(argument, helas_objects.HelasAmplitude) and \
+           argument.get('interaction_id') == 0:
+            call = "#"
+            call_function = lambda amp: call
+            self.add_amplitude(argument.get_call_key(), call_function)
+            return
+
+        if isinstance(argument, helas_objects.HelasWavefunction) and \
+               not argument.get('mothers'):
+            # String is just IXXXXX, OXXXXX, VXXXXX or SXXXXX
+            call = call + HelasFortranModel.mother_dict[\
+                argument.get_spin_state_number()]
+            # Fill out with X up to 6 positions
+            call = call + 'X' * (11 - len(call))
+            call = call + "(P(0,%d),"
+            if argument.get('spin') != 1:
+                # For non-scalars, need mass and helicity
+                call = call + "%s,NHEL(%d),"
+            call = call + "%+d*IC(%d),W(1,%d))"
+            if argument.get('spin') == 1:
+                call_function = lambda wf: call % \
+                                (wf.get('number_external'),
+                                 # For boson, need initial/final here
+                                 (-1) ** (wf.get('state') == 'initial'),
+                                 wf.get('number_external'),
+                                 wf.get('number'))
+            elif argument.is_boson():
+                call_function = lambda wf: call % \
+                                (wf.get('number_external'),
+                                 wf.get('mass'),
+                                 wf.get('number_external'),
+                                 # For boson, need initial/final here
+                                 (-1) ** (wf.get('state') == 'initial'),
+                                 wf.get('number_external'),
+                                 wf.get('number'))
+            else:
+                call_function = lambda wf: call % \
+                                (wf.get('number_external'),
+                                 wf.get('mass'),
+                                 wf.get('number_external'),
+                                 # For fermions, need particle/antiparticle
+                                 - (-1) ** wf.get_with_flow('is_part'),
+                                 wf.get('number_external'),
+                                 wf.get('number'))
+        else:
+            # String is FOVXXX, FIVXXX, JIOXXX etc.
+
+            addition = argument.get('lorentz')
+            mother_state = UFOHelasFortranModel.sorted_letters(argument)
+
+            call += '%s_%s'% (addition, mother_state)
+
+            # Check if we need to append a charge conjugation flag
+            if argument.needs_hermitian_conjugate():
+                call = call + 'C'
+
+            # Add the wave function
+            call = call + '('
+            # Wavefunctions
+            call = call + "W(1,%d)," * len(argument.get('mothers'))
+            # Couplings
+            call = call + "%s,"
+            print call
+
+            if isinstance(argument, helas_objects.HelasWavefunction):
+                # Create call for wavefunction
+                print call
+                call_function = lambda wf: call % \
+                    tuple([mother.get('number') for mother in wf.get('mothers')]) + \
+                    (wf.get_with_flow('coupling'),
+                                     wf.get('mass'),
+                                     wf.get('width'),
+                                     wf.get('number'))
+                
+            else:
+                # Create call for amplitude
+                if len(argument.get('mothers')) == 3:
+                    call_function = lambda amp: call % \
+                                    (amp.get('mothers')[0].\
+                                     get('number'),
+                                     amp.get('mothers')[1].\
+                                     get('number'),
+                                     amp.get('mothers')[2].\
+                                     get('number'),
+
+                                     amp.get('coupling'),
+                                     amp.get('number'))
+                else:
+                    call_function = lambda amp: call % \
+                                    (amp.get('mothers')[0].\
+                                     get('number'),
+                                     amp.get('mothers')[1].\
+                                     get('number'),
+                                     amp.get('mothers')[2].\
+                                     get('number'),
+                                     amp.get('mothers')[3].\
+                                     get('number'),
+                                     amp.get('coupling'),
+                                     amp.get('number'))
+
+        # Add the constructed function to wavefunction or amplitude dictionary
+        if isinstance(argument, helas_objects.HelasWavefunction):
+            self.add_wavefunction(argument.get_call_key(), call_function)
+        else:
+            self.add_amplitude(argument.get_call_key(), call_function)
+
+    # Static helper functions
+
+    @staticmethod
+    def sorted_letters(arg):
+        """Gives a list of letters sorted according to
+        the order of letters in the Fortran Helas calls"""
+
+        def convert_bool(logical):
+                if logical: 
+                    return '1'
+                else:
+                    return '0'
+                
+        if isinstance(arg, helas_objects.HelasWavefunction):
+            print [dir(wf) for wf in arg.get('mothers')]        
+            return "".join([convert_bool(wf['onshell']) for wf in arg.get('mothers')])
+
+        if isinstance(arg, helas_objects.HelasAmplitude):
+            print 'amplitude'
+            print [dir(wf) for wf in arg.get('mothers')] 
+            return "".join(['1' for wf in arg.get('mothers')])
+
+
+
+#===============================================================================
 # Global helper methods
 #===============================================================================
 

=== modified file 'madgraph/iolibs/misc.py'
--- madgraph/iolibs/misc.py	2010-01-21 12:46:02 +0000
+++ madgraph/iolibs/misc.py	2010-05-27 13:49:08 +0000
@@ -63,3 +63,24 @@
 
     return info_dict
 
+
+
+
+#===============================================================================
+# find a executable
+#===============================================================================
+def which(program):
+    def is_exe(fpath):
+        return os.path.exists(fpath) and os.access(fpath, os.X_OK)
+
+    fpath, fname = os.path.split(program)
+    if fpath:
+        if is_exe(program):
+            return program
+    else:
+        for path in os.environ["PATH"].split(os.pathsep):
+            exe_file = os.path.join(path, program)
+            if is_exe(exe_file):
+                return exe_file
+
+    return None
\ No newline at end of file

=== modified file 'tests/parallel_tests/me_comparator.py'
--- tests/parallel_tests/me_comparator.py	2010-05-19 08:41:14 +0000
+++ tests/parallel_tests/me_comparator.py	2010-05-27 14:27:58 +0000
@@ -36,6 +36,7 @@
 sys.path.append(os.sep.join(script_path.split(os.sep)[:-2]))
 
 import madgraph.iolibs.template_files as template_files
+import madgraph.iolibs.misc as misc
 
 class MERunner(object):
     """Base class to containing default function to setup, run and access results
@@ -82,8 +83,13 @@
     """Runner object for the MG4 Matrix Element generator."""
 
     mg4_path = ""
-
+    
     name = 'MadGraph v4'
+    
+    compilator ='f77'
+    if misc.which('gfortran'):
+        print 'use gfortran'
+        compilator = 'gfortran'
 
     def setup(self, mg4_path, temp_dir=None):
         """Setup routine: create a temporary copy of Template and execute the
@@ -217,7 +223,7 @@
 
         logging.info("Working on process %s in dir %s" % (proc,
                                                           shell_name))
-
+        
         dir_name = os.path.join(self.mg4_path, self.temp_dir_name, 'SubProcesses', shell_name)
         # If directory doesn't exist, skip and return 0
         if not os.path.isdir(dir_name):
@@ -228,7 +234,7 @@
         # Run make
         retcode = subprocess.call('make',
                         cwd=dir_name,
-                        stdout=open('/dev/null', 'w'), stderr=subprocess.STDOUT)
+                        stdout=open('/dev/null', 'w'))#, stderr=subprocess.STDOUT)
         if retcode != 0:
             logging.info("Error while executing make in %s" % shell_name)
             return ((0.0, 0), [])
@@ -248,7 +254,7 @@
         """Parse the output string and return a pair where first value is 
         the ME value and GeV exponent and the second value is a list of 4 
         momenta for all particles involved."""
-
+        print output
         res_p = []
         value = 0.0
         gev_pow = 0
@@ -324,10 +330,10 @@
 
         # Run mg5
         logging.info("Running mg5")
-        subprocess.call([os.path.join('bin', 'mg5'),
+        devnull = os.open(os.devnull, os.O_RDWR)
+        subprocess.call([os.path.join(self.mg5_path, 'bin', 'mg5'),
                         "-f%s" % os.path.join(dir_name, 'Cards', 'proc_card_v5.dat')],
-                        cwd=self.mg5_path,
-                        stdout=open('/dev/null', 'w'), stderr=subprocess.STDOUT)
+                        stdout=devnull, stderr=subprocess.STDOUT)
 
         # Perform some setup (normally done by newprocess_sa)
 
@@ -351,6 +357,16 @@
         shutil.copy(os.path.join(dir_name, 'Source', 'MODEL', 'param_card.dat'),
                    os.path.join(dir_name, 'Cards'))
 
+        #Pass to gfortran if needed.
+        if self.compilator == 'gfortran':
+            retcode = subprocess.call(['python', os.path.join('bin','Passto_gfortran.py')],
+                        cwd=os.path.join(self.mg4_path, self.temp_dir_name),
+                        stdout=open('/dev/null', 'w'), stderr=subprocess.STDOUT)
+            if retcode != 0:
+                print 'out gfortran'
+                logging.info("Error while passing to gfortran in %s" % shell_name)
+                return ((0.0, 0), [])
+
         # Run make
         retcode = subprocess.call(['make', '../lib/libdhelas3.a'],
                         cwd=os.path.join(dir_name, 'Source'),
@@ -526,3 +542,6 @@
     return res_list
 
 
+
+
+

=== modified file 'tests/parallel_tests/sample_script.py'
--- tests/parallel_tests/sample_script.py	2010-05-19 08:41:14 +0000
+++ tests/parallel_tests/sample_script.py	2010-05-27 13:17:26 +0000
@@ -20,14 +20,30 @@
 """
 
 import logging
+import os
 import me_comparator
 
 # Get full logging info
 #logging.basicConfig(level=logging.INFO)
 
 # specify the position of different codes
-mg4_path = "MG_ME"
-mg5_path = "../../"
+#position of MG_ME
+#position of MG5
+mg5_path = os.sep.join(os.path.realpath(__file__).split(os.sep)[:-3])
+print 'mg5_path', mg5_path
+mg4_path = None
+mg4_dir_possibility = [os.path.join(mg5_path, os.path.pardir),
+                os.path.join(os.getcwd(), os.path.pardir),
+                os.getcwd()]
+
+for position in mg4_dir_possibility:
+    if os.path.exists(os.path.join(position, 'MGMEVersion.txt')) and \
+                    os.path.exists(os.path.join(position, 'UpdateNotes.txt')):
+        mg4_path = os.path.realpath(position)
+        break
+del mg4_dir_possibility
+print 'mg4_path', mg4_path
+
 
 # Create a list of processes to check automatically
 my_proc_list = me_comparator.create_proc_list(['w+', 'w-', 'a', 'h'],

=== modified file 'tests/test_manager.py'
--- tests/test_manager.py	2010-05-19 09:26:34 +0000
+++ tests/test_manager.py	2010-05-25 06:57:45 +0000
@@ -161,8 +161,8 @@
         """ Find the different class instance derivated of TestCase """
 
         pyname = self.passin_pyformat(filename)
-        exec('import ' + pyname + ' as obj')
-
+        __import__(pyname)
+        obj = sys.modules[pyname]
         #look at class
         for name in dir(obj):
             class_ = getattr(obj, name)

