################################################################################
#
# Copyright (c) 2009 The MadGraph Development team and Contributors
#
# This file is a part of the MadGraph 5 project, an application which 
# automatically generates Feynman diagrams and matrix elements for arbitrary
# high-energy processes in the Standard Model and beyond.
#
# It is subject to the MadGraph license which should accompany this 
# distribution.
#
# For more information, please visit: http://madgraph.phys.ucl.ac.be
#
################################################################################

"""Methods and classes to export matrix elements to v4 format."""

import logging
import copy
import re

import madgraph.core.helas_objects as helas_objects
import madgraph.iolibs.misc as misc

#===============================================================================
# write_amplitude_v4_standalone
#===============================================================================
def write_matrix_element_v4_standalone(fsock, matrix_element, fortran_model):
    """Export a matrix element to a matrix.f file in MG4 standalone format"""
 
    if not matrix_element.get('processes') or \
           not matrix_element.get('diagrams'):
        return 0

    writer = FortranWriter()
    # Set lowercase/uppercase Fortran code
    writer.downcase = True

    replace_dict = {}

    # Extract version number and date from VERSION file
    info = misc.get_pkg_info()
    info_lines = ""
    if info.has_key('version') and  info.has_key('date'):
        info_lines = "#  Generated by MadGraph 5 v. %s, %s\n" % \
                     (info['version'], info['date'])
        info_lines = info_lines + \
                     "#  By the MadGraph Development Team\n" + \
                     "#  Please visit us at https://launchpad.net/madgraph5"
    replace_dict['info_lines'] = info_lines

    # Extract process info lines
    process_lines = "\n".join([ "#" + process.nice_string() for process in \
                                matrix_element.get('processes')])
    replace_dict['process_lines'] = process_lines

    # Extract crossing info lines - FIX
    crossing_lines = "C Crossing   1 is d u~ -> e- ve~  "
    replace_dict['crossing_lines'] = crossing_lines

    # Extract number of external particles
    nexternal = len(matrix_element.get('processes')[0].get('legs'))
    replace_dict['nexternal'] = nexternal

    # Extract ncomb - FIX
    ncomb = 48
    replace_dict['ncomb'] = ncomb

    # Extract ncross - FIX
    ncross = 1
    replace_dict['ncross'] = ncross

    # Extract helicity lines - FIX
    helicity_lines = """DATA (NHEL(IHEL,   1),IHEL=1, 6) /-1,-1,-1,-1,-1,-1/
      DATA (NHEL(IHEL,   2),IHEL=1, 6) /-1,-1,-1,-1, 0,-1/
      DATA (NHEL(IHEL,   3),IHEL=1, 6) /-1,-1,-1,-1, 1,-1/
      DATA (NHEL(IHEL,   4),IHEL=1, 6) /-1,-1,-1, 1,-1,-1/
      DATA (NHEL(IHEL,   5),IHEL=1, 6) /-1,-1,-1, 1, 0,-1/
      DATA (NHEL(IHEL,   6),IHEL=1, 6) /-1,-1,-1, 1, 1,-1/
      DATA (NHEL(IHEL,   7),IHEL=1, 6) /-1,-1, 1,-1,-1,-1/
      DATA (NHEL(IHEL,   8),IHEL=1, 6) /-1,-1, 1,-1, 0,-1/
      DATA (NHEL(IHEL,   9),IHEL=1, 6) /-1,-1, 1,-1, 1,-1/
      DATA (NHEL(IHEL,  10),IHEL=1, 6) /-1,-1, 1, 1,-1,-1/
      DATA (NHEL(IHEL,  11),IHEL=1, 6) /-1,-1, 1, 1, 0,-1/
      DATA (NHEL(IHEL,  12),IHEL=1, 6) /-1,-1, 1, 1, 1,-1/
      DATA (NHEL(IHEL,  13),IHEL=1, 6) /-1, 1,-1,-1,-1,-1/
      DATA (NHEL(IHEL,  14),IHEL=1, 6) /-1, 1,-1,-1, 0,-1/
      DATA (NHEL(IHEL,  15),IHEL=1, 6) /-1, 1,-1,-1, 1,-1/
      DATA (NHEL(IHEL,  16),IHEL=1, 6) /-1, 1,-1, 1,-1,-1/
      DATA (NHEL(IHEL,  17),IHEL=1, 6) /-1, 1,-1, 1, 0,-1/
      DATA (NHEL(IHEL,  18),IHEL=1, 6) /-1, 1,-1, 1, 1,-1/
      DATA (NHEL(IHEL,  19),IHEL=1, 6) /-1, 1, 1,-1,-1,-1/
      DATA (NHEL(IHEL,  20),IHEL=1, 6) /-1, 1, 1,-1, 0,-1/
      DATA (NHEL(IHEL,  21),IHEL=1, 6) /-1, 1, 1,-1, 1,-1/
      DATA (NHEL(IHEL,  22),IHEL=1, 6) /-1, 1, 1, 1,-1,-1/
      DATA (NHEL(IHEL,  23),IHEL=1, 6) /-1, 1, 1, 1, 0,-1/
      DATA (NHEL(IHEL,  24),IHEL=1, 6) /-1, 1, 1, 1, 1,-1/
      DATA (NHEL(IHEL,  25),IHEL=1, 6) / 1,-1,-1,-1,-1,-1/
      DATA (NHEL(IHEL,  26),IHEL=1, 6) / 1,-1,-1,-1, 0,-1/
      DATA (NHEL(IHEL,  27),IHEL=1, 6) / 1,-1,-1,-1, 1,-1/
      DATA (NHEL(IHEL,  28),IHEL=1, 6) / 1,-1,-1, 1,-1,-1/
      DATA (NHEL(IHEL,  29),IHEL=1, 6) / 1,-1,-1, 1, 0,-1/
      DATA (NHEL(IHEL,  30),IHEL=1, 6) / 1,-1,-1, 1, 1,-1/
      DATA (NHEL(IHEL,  31),IHEL=1, 6) / 1,-1, 1,-1,-1,-1/
      DATA (NHEL(IHEL,  32),IHEL=1, 6) / 1,-1, 1,-1, 0,-1/
      DATA (NHEL(IHEL,  33),IHEL=1, 6) / 1,-1, 1,-1, 1,-1/
      DATA (NHEL(IHEL,  34),IHEL=1, 6) / 1,-1, 1, 1,-1,-1/
      DATA (NHEL(IHEL,  35),IHEL=1, 6) / 1,-1, 1, 1, 0,-1/
      DATA (NHEL(IHEL,  36),IHEL=1, 6) / 1,-1, 1, 1, 1,-1/
      DATA (NHEL(IHEL,  37),IHEL=1, 6) / 1, 1,-1,-1,-1,-1/
      DATA (NHEL(IHEL,  38),IHEL=1, 6) / 1, 1,-1,-1, 0,-1/
      DATA (NHEL(IHEL,  39),IHEL=1, 6) / 1, 1,-1,-1, 1,-1/
      DATA (NHEL(IHEL,  40),IHEL=1, 6) / 1, 1,-1, 1,-1,-1/
      DATA (NHEL(IHEL,  41),IHEL=1, 6) / 1, 1,-1, 1, 0,-1/
      DATA (NHEL(IHEL,  42),IHEL=1, 6) / 1, 1,-1, 1, 1,-1/
      DATA (NHEL(IHEL,  43),IHEL=1, 6) / 1, 1, 1,-1,-1,-1/
      DATA (NHEL(IHEL,  44),IHEL=1, 6) / 1, 1, 1,-1, 0,-1/
      DATA (NHEL(IHEL,  45),IHEL=1, 6) / 1, 1, 1,-1, 1,-1/
      DATA (NHEL(IHEL,  46),IHEL=1, 6) / 1, 1, 1, 1,-1,-1/
      DATA (NHEL(IHEL,  47),IHEL=1, 6) / 1, 1, 1, 1, 0,-1/
      DATA (NHEL(IHEL,  48),IHEL=1, 6) / 1, 1, 1, 1, 1,-1/
      DATA (  IC(IHEL,  1),IHEL=1, 6) / 1, 2, 3, 4, 5, 6/
      DATA (IDEN(IHEL),IHEL=  1,  1) /   4/"""
    replace_dict['helicity_lines'] = helicity_lines

    # Extract ngraphs
    ngraphs = len(matrix_element.get('diagrams'))
    replace_dict['ngraphs'] = ngraphs

    # Extract neigen - FIX
    neigen = 1
    replace_dict['neigen'] = neigen

    # Extract nwavefuncs
    nwavefuncs = sum([ len(d.get('wavefunctions')) for d in \
                       matrix_element.get('diagrams')])
    replace_dict['nwavefuncs'] = nwavefuncs

    # Extract ncolor - FIX!
    ncolor = 1
    replace_dict['ncolor'] = ncolor

    # Extract color data lines - FIX!
    color_data_lines = """DATA Denom(1)/1/
                          DATA (CF(i,1),i=1,1) /1/"""
    replace_dict['color_data_lines'] = color_data_lines

    # Extract helas calls
    helas_call_list = fortran_model.get_matrix_element_calls(\
                matrix_element)
    helas_calls = "\n".join(helas_call_list)
    replace_dict['helas_calls'] = helas_calls

    # Extract helas calls
    jamp_lines = fortran_model.get_JAMP_line(matrix_element)
    replace_dict['jamp_lines'] = jamp_lines

    file = \
"""      SUBROUTINE SMATRIX(P1,ANS)
C  
%(info_lines)s
C 
C MadGraph StandAlone Version
C 
C Returns amplitude squared summed/avg over colors
c and helicities
c for the point in phase space P(0:3,NEXTERNAL)
C  
%(process_lines)s
C  
%(crossing_lines)s
      IMPLICIT NONE
C  
C CONSTANTS
C  
      integer    nexternal
      parameter (nexternal=%(nexternal)d)
      INTEGER                 NCOMB,  NCROSS         
      PARAMETER (             NCOMB=%(ncomb)d, NCROSS=%(ncross)d)
      INTEGER    THEL
      PARAMETER (THEL=NCOMB*NCROSS)
C  
C ARGUMENTS 
C  
      REAL*8 P1(0:3,NEXTERNAL),ANS(NCROSS)
C  
C LOCAL VARIABLES 
C  
      INTEGER NHEL(NEXTERNAL,NCOMB),NTRY
      REAL*8 T, P(0:3,NEXTERNAL)
      REAL*8 MATRIX
      INTEGER IHEL,IDEN(NCROSS),IC(NEXTERNAL,NCROSS)
      INTEGER IPROC,JC(NEXTERNAL), I
      LOGICAL GOODHEL(NCOMB,NCROSS)
      DATA NTRY/0/
      DATA GOODHEL/THEL*.FALSE./
%(helicity_lines)s
C ----------
C BEGIN CODE
C ----------
      NTRY=NTRY+1
      DO IPROC=1,NCROSS
      CALL SWITCHMOM(P1,P,IC(1,IPROC),JC,NEXTERNAL)
      DO IHEL=1,NEXTERNAL
         JC(IHEL) = +1
      ENDDO
      ANS(IPROC) = 0D0
          DO IHEL=1,NCOMB
             IF (GOODHEL(IHEL,IPROC) .OR. NTRY .LT. 2) THEN
                 T=MATRIX(P ,NHEL(1,IHEL),JC(1))            
               ANS(IPROC)=ANS(IPROC)+T
               IF (T .NE. 0D0 .AND. .NOT.    GOODHEL(IHEL,IPROC)) THEN
                   GOODHEL(IHEL,IPROC)=.TRUE.
               ENDIF
             ENDIF
          ENDDO
      ANS(IPROC)=ANS(IPROC)/DBLE(IDEN(IPROC))
      ENDDO
      END
       
       
      REAL*8 FUNCTION MATRIX(P,NHEL,IC)
C  
%(info_lines)s
C
C Returns amplitude squared summed/avg over colors
c for the point with external lines W(0:6,NEXTERNAL)
C  
%(process_lines)s
C  
      IMPLICIT NONE
C  
C CONSTANTS
C  
      INTEGER    NGRAPHS, NEIGEN 
      PARAMETER (NGRAPHS=%(ngraphs)d, NEIGEN=%(neigen)d) 
      integer    nexternal
      parameter (nexternal=%(nexternal)d)
      INTEGER    NWAVEFUNCS, NCOLOR
      PARAMETER (NWAVEFUNCS=%(nwavefuncs)d, NCOLOR=%(ncolor)d) 
      REAL*8     ZERO
      PARAMETER (ZERO=0D0)
C  
C ARGUMENTS 
C  
      REAL*8 P(0:3,NEXTERNAL)
      INTEGER NHEL(NEXTERNAL), IC(NEXTERNAL)
C  
C LOCAL VARIABLES 
C  
      INTEGER I,J
      COMPLEX*16 ZTEMP
      REAL*8 DENOM(NCOLOR), CF(NCOLOR,NCOLOR)
      COMPLEX*16 AMP(NGRAPHS), JAMP(NCOLOR)
      COMPLEX*16 W(18,NWAVEFUNCS)
C  
C GLOBAL VARIABLES
C  
      include "coupl.inc"
C  
C COLOR DATA
C  
%(color_data_lines)s
C ----------
C BEGIN CODE
C ----------
%(helas_calls)s
%(jamp_lines)s
      MATRIX = 0.D0 
      DO I = 1, NCOLOR
          ZTEMP = (0.D0,0.D0)
          DO J = 1, NCOLOR
              ZTEMP = ZTEMP + CF(J,I)*JAMP(J)
          ENDDO
          MATRIX =MATRIX+ZTEMP*DCONJG(JAMP(I))/DENOM(I)   
      ENDDO
C      CALL GAUGECHECK(JAMP,ZTEMP,EIGEN_VEC,EIGEN_VAL,NCOLOR,NEIGEN) 
      END
       
       
      subroutine switchmom(p1,p,ic,jc,nexternal)
      implicit none
      integer nexternal
      integer jc(nexternal),ic(nexternal)
      real*8 p1(0:3,nexternal),p(0:3,nexternal)
      integer i,j
      do i=1,nexternal
         do j=0,3
            p(j,ic(i))=p1(j,i)
         enddo
      enddo
      do i=1,nexternal
         jc(i)=1
      enddo
      jc(ic(1))=-1
      jc(ic(2))=-1
      end""" % replace_dict

    # Write the file
    for line in file.split('\n'):
        writer.write_fortran_line(fsock, line)

    return len(helas_call_list)

#===============================================================================
# FortranWriter
#===============================================================================
class FortranWriter():
    """Routines for writing fortran lines. Keeps track of indentation
    and splitting of long lines"""

    # Parameters defining the output of the Fortran writer
    keyword_pairs = {'^if.+then\s*$': ('^endif', 2),
                     '^do': ('^enddo\s*$', 2),
                     '^subroutine': ('^end\s*$', 0),
                     'function': ('^end\s*$', 0)}
    single_indents = {'^else\s*$': -2,
                      '^else\s*if.+then\s*$': -2}
    line_cont_char = '$'
    comment_char = 'c'
    downcase = False
    line_length = 71
    max_split = 10
    split_characters = "+-*/, "
    comment_split_characters = " "

    # Private variables
    __indent = 0
    __keyword_list = []
    
    def write_fortran_line(self, fsock, line):
        """Write a fortran line, with correct indent and line splits"""

        if not isinstance(line, str) or line.find('\n') >= 0:
            raise FortranWriterError,\
                  "write_fortran_line must have a single line as argument"

        # Check if this line is a comment
        comment = False
        if re.search("^#", line.lstrip()) or \
           re.search("^c$", line, re.IGNORECASE) or \
               re.search("^c\s+", line, re.IGNORECASE) and \
               not re.search("^c\s+=", line, re.IGNORECASE):
            # This is a comment
            myline = " " * (5 + self.__indent) + line.lstrip()[1:].lstrip()
            if self.downcase:
                self.comment_char = self.comment_char.lower()
            else:
                self.comment_char = self.comment_char.upper()
            myline = self.comment_char + myline
            res = [myline]
            part = ""
            post_comment = ""
            # Break line in appropriate places
            # defined (in priority order) by the characters in split_characters
            while len(res[len(res) - 1]) > self.line_length:
                split_at = self.line_length
                for character in self.split_characters:
                    index = res[len(res) - 1][(self.line_length - self.max_split):\
                                              self.line_length].rfind(character)
                    if index >= 0:
                        split_at = self.line_length - self.max_split + index
                        break
                    
                res.append(self.comment_char + " " * (5 + self.__indent) + \
                           res[len(res) - 1][split_at:])
                res[len(res) - 2] = res[len(res) - 2][:split_at]
        else:
            # This is a regular Fortran line

            # Strip leading spaces from line
            myline = line.lstrip()

            # Convert to upper or lower case
            # Here we need to make exception for anything within quotes.
            (myline, part, post_comment) = myline.partition("!")
            # Replace all double quotes by single quotes
            myline = myline.replace('\"','\'')
            # Downcase or upcase Fortran code, except for quotes
            splitline = myline.split('\'')
            myline = ""
            i = 0
            while i < len(splitline):
                if i % 2 == 1:
                    # This is a quote - check for escaped \'s
                    while splitline[i][len(splitline[i]) - 1] == '\\':
                        splitline[i] = splitline[i] + '\'' + splitline.pop(i+1)
                else:
                    # Otherwise downcase/upcase
                    if self.downcase:
                        splitline[i] = splitline[i].lower()
                    else:
                        splitline[i] = splitline[i].upper()
                i = i + 1

            myline = "\'".join(splitline).rstrip()

            # Check if line starts with dual keyword and adjust indent 
            if self.__keyword_list and re.search(self.keyword_pairs[\
                self.__keyword_list[len(self.__keyword_list) - 1]][0],
                                               myline.lower()):
                key = self.__keyword_list.pop()
                self.__indent = self.__indent - self.keyword_pairs[key][1]

            # Check for else and else if
            single_indent = 0
            for key in self.single_indents.keys():
                if re.search(key, myline.lower()):
                    self.__indent = self.__indent + self.single_indents[key]
                    single_indent = -self.single_indents[key]
                    break
                
            # Use our own indent
            res = [" " * (6 + self.__indent) + myline]

            # Break line in appropriate places
            # defined (in priority order) by the characters in split_characters
            while len(res[len(res) - 1]) > self.line_length:
                split_at = self.line_length
                for character in self.split_characters:
                    index = res[len(res) - 1][(self.line_length - self.max_split):\
                                              self.line_length].rfind(character)
                    if index >= 0:
                        split_at = self.line_length - self.max_split + index
                        break
                    
                res.append(" " * 5 + self.line_cont_char + \
                           " " * (self.__indent + 1) + \
                           res[len(res) - 1][split_at:])
                res[len(res) - 2] = res[len(res) - 2][:split_at]

            # Check if line starts with keyword and adjust indent 
            for key in self.keyword_pairs.keys():
                if re.search(key, myline.lower()):
                    self.__keyword_list.append(key)
                    self.__indent = self.__indent + self.keyword_pairs[key][1]
                    break
        
            # Correct back for else and else if
            if single_indent != None:
                self.__indent = self.__indent + single_indent
                single_indent = None

        # Write line(s) to file
        fsock.write("\n".join(res)+ part + post_comment + "\n")

        return True

#===============================================================================
# HelasFortranModel
#===============================================================================
class HelasFortranModel(helas_objects.HelasModel):
    """The class for writing Helas calls in Fortran, starting from
    HelasWavefunctions and HelasAmplitudes."""

    mother_dict = {1: 'S', 2: 'O', -2: 'I', 3: 'V', 5: 'T'}
    self_dict = {1: 'H', 2: 'F', -2: 'F', 3: 'J', 5: 'U'}
    sort_wf = {'O': 0, 'I': 1, 'S': 2, 'T': 3, 'V': 4}
    sort_amp = {'S': 1, 'V': 2, 'T': 0, 'O': 3, 'I': 4}


    def default_setup(self):

        super(HelasFortranModel, self).default_setup()

        # Add special fortran Helas calls, which are not automatically
        # generated


        # Gluon 4-vertex division tensor calls ggT for the FR sm and mssm
        key = ((3,3,5),tuple('A'))
        call_function = lambda wf: \
                        "CALL UVVAXX(W(1,%d),W(1,%d),%s,zero,zero,zero,W(1,%d))" % \
                        (HelasFortranModel.sorted_mothers(wf)[0].get('number'),
                         HelasFortranModel.sorted_mothers(wf)[1].get('number'),
                         wf.get('couplings')[(0,0)],
                         wf.get('number'))
        self.add_wavefunction(key,call_function)

        key = ((3,5,3),tuple('A'))
        call_function = lambda wf: \
                        "CALL JVTAXX(W(1,%d),W(1,%d),%s,zero,zero,W(1,%d))" % \
                        (HelasFortranModel.sorted_mothers(wf)[0].get('number'),
                         HelasFortranModel.sorted_mothers(wf)[1].get('number'),
                         wf.get('couplings')[(0,0)],
                         wf.get('number'))
        self.add_wavefunction(key,call_function)

        key = ((3,3,5),tuple('A'))
        call_function = lambda amp: \
                        "CALL VVTAXX(W(1,%d),W(1,%d),W(1,%d),%s,zero,AMP(%d))" % \
                        (HelasFortranModel.sorted_mothers(amp)[0].get('number'),
                         HelasFortranModel.sorted_mothers(amp)[1].get('number'),
                         HelasFortranModel.sorted_mothers(amp)[2].get('number'),
                         amp.get('couplings')[(0,0)],
                         amp.get('number'))
        self.add_amplitude(key,call_function)

    def get_wavefunction_call(self, wavefunction):
        """Return the function for writing the wavefunction
        corresponding to the key"""

        val = super(HelasFortranModel, self).get_wavefunction_call(wavefunction)

        if val:
            return val

        # If function not already existing, try to generate it.

        if len(wavefunction.get('mothers')) > 3:
            raise self.PhysicsObjectError,\
                  """Automatic generation of Fortran wavefunctions not
                  implemented for > 3 mothers"""

        self.generate_helas_call(wavefunction)
        return super(HelasFortranModel, self).get_wavefunction_call(wavefunction)

    def get_amplitude_call(self, amplitude):
        """Return the function for writing the amplitude
        corresponding to the key"""

        val = super(HelasFortranModel, self).get_amplitude_call(amplitude)

        if val:
            return val

        # If function not already existing, try to generate it.

        if len(amplitude.get('mothers')) > 4:
            raise self.PhysicsObjectError,\
                  """Automatic generation of Fortran amplitudes not
                  implemented for > 4 mothers"""

        self.generate_helas_call(amplitude)
        return super(HelasFortranModel, self).get_amplitude_call(amplitude)

    def generate_helas_call(self, argument):
            
        if not isinstance(argument, helas_objects.HelasWavefunction) and \
           not isinstance(argument, helas_objects.HelasAmplitude):
            raise self.PhysicsObjectError, \
                  "get_helas_call must be called with wavefunction or amplitude"

        call = "CALL "

        call_function = None
            
        if isinstance(argument, helas_objects.HelasWavefunction) and \
               not argument.get('mothers'):
            # String is just IXXXXX, OXXXXX, VXXXXX or SXXXXX
            call = call + HelasFortranModel.mother_dict[\
                argument.get_spin_state_number()]
            # Fill out with X up to 6 positions
            call = call + 'X' * (11 - len(call))
            call = call + "(P(0,%d),"
            if argument.get('spin') != 1:
                # For non-scalars, need mass and helicity
                call = call + "%s,NHEL(%d),"
            call = call + "%d*IC(%d),W(1,%d))"
            if argument.get('spin') == 1:
                call_function = lambda wf: call % \
                                (wf.get('number_external'),
                                 # For boson, need initial/final here
                                 (-1)**(wf.get('state') == 'initial'),
                                 wf.get('number_external'),
                                 wf.get('number'))
            elif argument.is_boson():
                call_function = lambda wf: call % \
                                (wf.get('number_external'),
                                 wf.get('mass'),
                                 wf.get('number_external'),
                                 # For boson, need initial/final here
                                 (-1)**(wf.get('state')=='initial'),
                                 wf.get('number_external'),
                                 wf.get('number'))
            else:
                call_function = lambda wf: call % \
                                (wf.get('number_external'),
                                 wf.get('mass'),
                                 wf.get('number_external'),
                                 # For fermions, need particle/antiparticle
                                 -(-1)**wf.get_with_flow('is_part'),
                                 wf.get('number_external'),
                                 wf.get('number'))
        else:
            # String is FOVXXX, FIVXXX, JIOXXX etc.
            if isinstance(argument, helas_objects.HelasWavefunction):
                call = call + \
                       HelasFortranModel.self_dict[\
                argument.get_spin_state_number()]

            mother_letters = HelasFortranModel.sorted_letters(argument)

            # If Lorentz structure is given, by default add this
            # to call name
            addition = argument.get('lorentz')[0]

            # Take care of special case: WWWW or WWVV calls
            if len(argument.get('lorentz')[0]) > 3 and \
                   argument.get('lorentz')[0][:2] == "WW":
                if argument.get('lorentz')[0][:4] == "WWWW":
                    mother_letters = "WWWW"[:len(mother_letters)]
                if argument.get('lorentz')[0][:4] == "WWVV":
                    mother_letters = "W3W3"[:len(mother_letters)]
                addition = argument.get('lorentz')[0][4:]

            call = call + mother_letters
            call = call + addition

            # Check if we need to append a charge conjugation flag
            if argument.needs_hermitian_conjugate():
                call = call + 'C'

            if len(call) > 11:
                raise self.PhysicsObjectError, \
                      "Too long call to Helas routine %s, should be maximum 6 characters" \
                      % call[5:]

            # Fill out with X up to 6 positions
            call = call + 'X' * (11 - len(call)) + '('
            # Wavefunctions
            call = call + "W(1,%d)," * len(argument.get('mothers'))
            # Couplings
            call = call + "%s," * min(2,len(argument.get('couplings').keys()))

            if isinstance(argument, helas_objects.HelasWavefunction):
                # Mass and width
                call = call + "%s,%s,"
                # New wavefunction
                call = call + "W(1,%d))"
            else:
                # Amplitude
                call = call + "AMP(%d))"                

            if isinstance(argument,helas_objects.HelasWavefunction):
                # Create call for wavefunction
                if len(argument.get('couplings').keys()) == 1:
                    call_function = lambda wf: call % \
                                    (HelasFortranModel.sorted_mothers(wf)[0].get('number'),
                                     HelasFortranModel.sorted_mothers(wf)[1].get('number'),
                                     wf.get_with_flow('couplings')[(0,0)],
                                     wf.get('mass'),
                                     wf.get('width'),
                                     wf.get('number'))
                else:
                    call_function = lambda wf: call % \
                                    (HelasFortranModel.sorted_mothers(wf)[0].get('number'),
                                     HelasFortranModel.sorted_mothers(wf)[1].get('number'),
                                     HelasFortranModel.sorted_mothers(wf)[2].get('number'),
                                     wf.get_with_flow('couplings')[(0,0)],
                                     wf.get_with_flow('couplings')[(0,1)],
                                     wf.get('mass'),
                                     wf.get('width'),
                                     wf.get('number'))
            else:
                # Create call for amplitude
                if len(argument.get('couplings').keys()) == 1:
                    call_function = lambda amp: call % \
                                    (HelasFortranModel.sorted_mothers(amp)[0].get('number'),
                                     HelasFortranModel.sorted_mothers(amp)[1].get('number'),
                                     HelasFortranModel.sorted_mothers(amp)[2].get('number'),
                                     amp.get('couplings')[(0,0)],
                                     amp.get('number'))
                else:
                    call_function = lambda amp: call % \
                                    (HelasFortranModel.sorted_mothers(amp)[0].get('number'),
                                     HelasFortranModel.sorted_mothers(amp)[1].get('number'),
                                     HelasFortranModel.sorted_mothers(amp)[2].get('number'),
                                     HelasFortranModel.sorted_mothers(amp)[3].get('number'),
                                     amp.get('couplings')[(0,0)],
                                     amp.get('couplings')[(0,1)],
                                     amp.get('number'))

        # Add the constructed function to wavefunction or amplitude dictionary
        if isinstance(argument,helas_objects.HelasWavefunction):
            self.add_wavefunction(argument.get_call_key(),call_function)
        else:
            self.add_amplitude(argument.get_call_key(),call_function)
            
    def get_JAMP_line(self, matrix_element):
        """Return the JAMP(1) = sum(fermionfactor * AMP(i)) line"""

        if not isinstance(matrix_element, helas_objects.HelasMatrixElement):
            raise self.PhysicsObjectError, \
                  "%s not valid argument for get_matrix_element_calls" % \
                  repr(matrix_element)

        res = "JAMP(1)="
        # Add all amplitudes with correct fermion factor
        for diagram in matrix_element.get('diagrams'):
            res = res + "%sAMP(%d)" % (sign(diagram.get('fermionfactor')),
                                         diagram.get('amplitude').get('number'))
        return res

    # Static helper functions

    @staticmethod
    def sorted_mothers(arg):
        """Gives a list of mother wavefunctions sorted according to
        1. the spin order needed in the Fortran Helas calls and
        2. the order of the particles in the interaction (cyclic)
        3. the number for the external leg"""

        if isinstance(arg, helas_objects.HelasWavefunction) or \
           isinstance(arg, helas_objects.HelasAmplitude):
            # First sort according to number_external number
            sorted_mothers1 = sorted(arg.get('mothers'),
                                     lambda wf1, wf2: \
                                     wf1.get('number_external') - \
                                     wf2.get('number_external'))
            # Next sort according to interaction pdg codes
            mother_codes = [ wf.get_pdg_code_outgoing() for wf in sorted_mothers1 ]
            pdg_codes = copy.copy(arg.get('pdg_codes'))
            if isinstance(arg, helas_objects.HelasWavefunction):
                my_code = arg.get_pdg_code_incoming()
                # We need to create the cyclic pdg_codes
                missing_index = pdg_codes.index(my_code)
                pdg_codes_cycl = pdg_codes[missing_index+1:]
                pdg_codes_cycl.extend(pdg_codes[:missing_index])
            else:
                pdg_codes_cycl = pdg_codes

            sorted_mothers2 = helas_objects.HelasWavefunctionList()
            for code in pdg_codes_cycl:
                index = mother_codes.index(code)
                mother_codes.pop(index)
                sorted_mothers2.append(sorted_mothers1.pop(index))

            if sorted_mothers1:
                raise HelasFortranModel.PhysicsObjectError,\
                          "Mismatch of pdg codes, %s != %s" % \
                          (repr(mother_codes),repr(pdg_codes_cycl))

            # Next sort according to spin_state_number
            return sorted(sorted_mothers2, lambda wf1, wf2: \
                          HelasFortranModel.sort_amp[\
                          HelasFortranModel.mother_dict[wf2.get_spin_state_number()]]\
                          - HelasFortranModel.sort_amp[\
                          HelasFortranModel.mother_dict[wf1.get_spin_state_number()]])
        
    @staticmethod
    def sorted_letters(arg):
        """Gives a list of letters sorted according to
        the order of letters in the Fortran Helas calls"""

        if isinstance(arg, helas_objects.HelasWavefunction):
            return "".join(sorted([HelasFortranModel.mother_dict[\
            wf.get_spin_state_number()] for wf in arg.get('mothers')],
                          lambda l1, l2: \
                          HelasFortranModel.sort_wf[l2] - \
                          HelasFortranModel.sort_wf[l1]))

        if isinstance(arg, helas_objects.HelasAmplitude):
            return "".join(sorted([HelasFortranModel.mother_dict[\
            wf.get_spin_state_number()] for wf in arg.get('mothers')],
                          lambda l1, l2: \
                          HelasFortranModel.sort_amp[l2] - \
                          HelasFortranModel.sort_amp[l1]))
    
#===============================================================================
# Global helper methods
#===============================================================================

def sign(number):
    """Returns '+' if positive, '-' if negative"""

    if number > 0:
        return '+'
    if number < 0:
        return '-'
    
